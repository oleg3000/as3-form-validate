/**  Copyright (c) 2011, CREATIVE AREA  All rights reserved.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions are  met:    * Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.  * Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the     documentation and/or other materials provided with the distribution.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. **//** * version: alpha-0 * date: 2011-02-23 * language: as3 * project url: http://code.google.com/p/as3-form-validate/ * blog url: http://js.creative-area.net * copyright: CREATIVE AREA **/package com.creativearea {	import com.creativearea.DataValidationResult;	import flash.net.*;	import com.creativearea.DataValidation;	import com.creativearea.DataValidationResult;import starling.display.Sprite;import starling.events.Event;public class FormValidate {				public var root:Object;		public var params:Object;				public var onSubmitError:Function;		public var showMessage:Function;				private var DV = new DataValidation;		private var DV_Result = new DataValidationResult;				public function FormValidate(r:Object, p:Object) {			/*			params :			{				url:"url"				stopOnError:Boolean,				errorTextField:"textfield_name", // if textfield is not directly in this.root, reassign showMessage function				fields:{					field_name:{						label:"display_name",						path:"path_to_field",						rules:{							required:Boolean,							email: Boolean,							minlength:Number,							maxlength:Number,							equalto:"field_name",							date:Boolean, // dd/mm/yyyy							serverdate:Boolean, // yyyy-mm-dd							ofage:Boolean // age not under 18						},						msg:{							required:"Message"						}						tabIndex:Number // tabulation index						cbGet:Boolean // call a method named "getValue_[field_name]()" to render the value. called internaly before rules validation						cbSend:"method_name" // call a method named "[method_name]" to transform the value. called internaly before submit. the return value remplace the get value.					},				}			}			*/						this.root = r;			this.params = (p)?p:{};			this.onSubmitError = onSubmitError_Default;			this.showMessage = showMessage_Default;						this.init();		}				public function init() {			// if needed		}				// get errors				public function getErrors():Array {			return this.params.errors;		}				// get field path				private function getFieldPath(field):Object {			if ( this.params.fields[field].path !== undefined ) {				// TODO : split path by "." for recursive path (mc in mc)				return this.root[this.params.fields[field].path][field];			} else {				return this.root[field];			}		}				// get field value				public function getFieldValue(field) {			if ( this.params.fields[field].cbGet !== undefined ) {				if ( this.params.fields[field].cbGet === true ) {					return this['getValue_'+field]();				} else {					return this[this.params.fields[field].cbGet]();				}			} else {				var field = this.getFieldPath(field);				return field.text;			}		}				// init tab index				public function initTabIndex():void {			for ( var p in this.params.fields ) {				if ( this.params.fields[p].tabIndex !== undefined ) {					var field = this.getFieldPath(p);					field.tabIndex = this.params.fields[p].tabIndex;				}			}		}				// forms validation				public function validate():Boolean {			if ( this.params !== null && this.params.fields !== undefined ) {				this.params.errors = [];				this.params.values = {};				for ( var p in this.params.fields ) {					var f = this.params.fields[p];					if ( f.label === undefined ) f.label = p;					var value = this.getFieldValue(p);					this.params.values[p] = value;					var breakField = false;					if ( f.rules !== undefined ) {						for ( var r in f.rules ) {							if ( !this['validateRule_'+r](value, f.rules[r]) ) {								// not valid								if ( f.msg && f.msg[r] ) {									this.params.errors.push(f.msg[r]);								} else {									this.params.errors.push(this['errorMessage_'+r](f.label));								}								if ( this.params.stopOnError ) {									breakField = true;								}								break;							}						}					}					if ( breakField ) {						break;					}				}				return ( this.params.errors.length == 0 );			} else {				return false;			}		}				// rules				public function validateRule_required(value, param):Boolean {			// TODO : param can be a function			return ( DV.isNotEmpty(value) );		}		public function validateRule_email(value, param):Boolean {			var vResult:DataValidationResult = DV.isEmail(value);			return vResult.result;		}		public function validateRule_digits(value, param):Boolean {			return DV.isDigits(value);		}		public function validateRule_minlength(value, param):Boolean {			return ( value.length >= param );		}		public function validateRule_maxlength(value, param):Boolean {			return ( value.length <= param );		}		public function validateRule_minvalue(value, param):Boolean {			return ( Number(value) >= param );		}		public function validateRule_maxvalue(value, param):Boolean {			return ( Number(value) <= param );		}		public function validateRule_equalto(value, param):Boolean {			return ( this.getFieldValue(param) == value );		}		public function validateRule_date(value, param):Boolean {			var vResult = DV.isWorldDate(value);			return vResult.result;		}		public function validateRule_serverdate(value, param):Boolean {			value = value.split('-').reverse().join('/');			var vResult = DV.isWorldDate(value);			return vResult.result;		}		public function validateRule_ofage(value, param):Boolean {			var date_now = new Date();			date_now.setHours(0,0,0,0);			var tdate = value.split('/');			var date_naissance = new Date(1*tdate[2], ( (1*tdate[1]) - 1 ), 1*tdate[0], 0, 0, 0, 0);			if ( date_now.getFullYear() - date_naissance.getFullYear() < 18 ) {				return false;			} else if ( date_now.getFullYear() - date_naissance.getFullYear() == 18 ) {				if ( date_naissance.getMonth() > date_now.getMonth() ) {					return false;				} else if ( date_naissance.getMonth() == date_now.getMonth() ) {					if ( date_naissance.getDate() > date_now.getDate() ) {						return false;					}				}			}			return true;		}				// default error messages				public function errorMessage_required(field):String {			return 'Field '+field+' is required !';		}		public function errorMessage_email(field):String {			return 'Email '+field+' must be valid !';		}		public function errorMessage_minlength(field):String {			return 'Field '+field+' is too small !';		}		public function errorMessage_maxlength(field):String {			return 'Field '+field+' is too big !';		}		public function errorMessage_equalto(field):String {			return 'Field '+field+' different !';		}		public function errorMessage_date(field):String {			return 'Field '+field+' is not a valid date (DD/MM/YYYY) !';		}		public function errorMessage_serverdate(field):String {			return 'Field '+field+' is not a valid server date (YYYY-MM-DD) !';		}				// add form values				public function addValues(_values:Object) {			this.params.values_ext = {};			for ( var p in _values ) {				this.params.values_ext[p] = _values[p]			}		}				// form send				public function submit(callback:Function) {			if ( this.params.url !== undefined ) {				if ( this.params.errors.length == 0 ) {					var loader:URLLoader = new URLLoader();					loader.addEventListener(Event.COMPLETE, callback);										var request:URLRequest = new URLRequest(this.params.url);					request.method = URLRequestMethod.POST;										var variables:URLVariables = new URLVariables();					for ( var p in this.params.values ) {						if ( this.params.fields[p].cbSend !== undefined ) {							variables[p] = this[this.params.fields[p].cbSend](this.params.values[p]);						} else {							variables[p] = this.params.values[p];						}					}					if ( this.params.values_ext !== undefined ) {						for ( p in this.params.values_ext ) {							variables[p] = this.params.values_ext[p];						}					}					request.data = variables;										try {						loader.load(request);					} catch (error:Error) {						this.onSubmitError({type:"server", message:"Unable to load requested document."});					}				} else {					this.onSubmitError({type:"form", message:"Form invalid: "+this.params.errors.join(', ')+"."});				}			} else {				this.onSubmitError({type:"config", message:"Need url param to send data."});			}		}				// event methods				// submit error				private function onSubmitError_Default(e:Object) {			trace("Error type:" + e.type + " ; message: "+e.message);		}				// show message in error field				private function showMessage_Default(m:String) {			if ( this.params.errorTextField !== undefined ) {				this.root[this.params.errorTextField].text = m;			} else {				trace(m);			}		}	}}